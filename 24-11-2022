{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 42,
   "id": "ba0c2cb0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1.13.0+cu117\n",
      "True\n"
     ]
    }
   ],
   "source": [
    "import torch\n",
    "import os\n",
    "import math\n",
    "import tarfile\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.ticker as ticker\n",
    "from collections import Counter\n",
    "from itertools import chain\n",
    "from sklearn.model_selection import StratifiedKFold\n",
    "from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.utils import gen_batches\n",
    "from torchvision import datasets, transforms\n",
    "import torch.nn as nn\n",
    "import torch.nn.functional as F\n",
    "from torch.utils.data import DataLoader, random_split\n",
    "import torch.optim as optim\n",
    "from copy import deepcopy\n",
    "from time import time\n",
    "import numpy as np\n",
    "from PIL import Image\n",
    "from torchvision import models\n",
    "from tqdm import tqdm\n",
    "from torch.utils.data.dataset import Dataset\n",
    "\n",
    "# just to ignore the matplotlib warnings to make the plots look better\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "# test whether the cuda is available\n",
    "# os.environ['CUDA_VISIBLE_DEVICES'] = '0'\n",
    "\n",
    "\n",
    "print(torch.__version__)\n",
    "print(torch.cuda.is_available())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "id": "a3437eaf",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "train_biz=pd.read_csv('./train_photo_to_biz_ids.csv')\n",
    "test_biz=pd.read_csv('./test_photo_to_biz.csv')\n",
    "train=pd.read_csv('./train.csv')\n",
    "sub=pd.read_csv('./sample_submission.csv')\n",
    "\n",
    "#print(train_biz)\n",
    "#print(test_biz)\n",
    "#print(train)\n",
    "#print(sub)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "id": "480b9f00",
   "metadata": {},
   "outputs": [],
   "source": [
    "# merging\n",
    "data=pd.merge(train_biz,train, on='business_id',how='left')\n",
    "# drop data that missing labels\n",
    "data=data.dropna(subset=['labels'])\n",
    "\n",
    "# for competition only\n",
    "data_task=pd.merge(test_biz,sub, on='business_id',how='left') "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "id": "894aa50f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# convert string to list of int\n",
    "labels=data['labels'].tolist()\n",
    "for index,x in enumerate(labels):\n",
    "     labels[index]= [int(c) for c in str(x).split(' ')]\n",
    "data['labels'] = labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "id": "bdb441c1",
   "metadata": {},
   "outputs": [],
   "source": [
    "# use small data set for development\n",
    "development_size=0.5\n",
    "unsued_data,data = train_test_split(data,test_size=development_size, random_state=40)\n",
    "\n",
    "train_data, test_data = train_test_split(data, test_size=0.1, random_state=40)\n",
    "train_data, val_data = train_test_split(train_data, test_size=0.1, random_state=40)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "id": "0c453694",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define dataset class\n",
    "\n",
    "\n",
    "class Image_Dataset(Dataset):\n",
    "    def __init__(self, data_path, data, transform=None):\n",
    "        self.image_id = data['photo_id'].tolist()\n",
    "        self.labels=data['labels'].tolist()\n",
    "        self.transform = transform\n",
    "        self.data_path = data_path\n",
    "        self.classes = [0,1,2,3,4,5,6,7,8]\n",
    "        \n",
    "          \n",
    "        for index in range(len(self.labels)):\n",
    "            labels = self.labels[index]\n",
    "            vector=[0,0,0,0,0,0,0,0,0]\n",
    "            for i in range(9):\n",
    "                if i in labels:\n",
    "                    vector[i] = 1\n",
    "            self.labels[index] = np.array(vector, dtype=float)\n",
    "\n",
    "    def __getitem__(self, index):\n",
    "        label = self.labels[index]\n",
    "        img_path = os.path.join(self.data_path, str(self.image_id[index])+'.jpg')\n",
    "        img = Image.open(img_path)\n",
    "        if self.transform:\n",
    "            # dont know why all output of the transform are negative\n",
    "            img = -self.transform(img)\n",
    "        return img, label\n",
    "    def __len__(self):\n",
    "        return len(self.image_id)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "id": "46a29a45",
   "metadata": {},
   "outputs": [],
   "source": [
    "# transformation\n",
    "\n",
    "mean = [0.485,0.456,0.406]\n",
    "std = [0.229,0.224,0.225]\n",
    "\n",
    "train_transform = transforms.Compose([\n",
    "        transforms.Resize([256, 256]),\n",
    "        transforms.ColorJitter(),\n",
    "        transforms.RandomHorizontalFlip(),\n",
    "        transforms.ToTensor(),\n",
    "        transforms.Normalize(mean=mean, std=std),\n",
    "        ])\n",
    "\n",
    "val_transform = transforms.Compose([\n",
    "    transforms.Resize((256, 256)),\n",
    "    transforms.ToTensor(),\n",
    "    transforms.Normalize(mean, std)\n",
    "])\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "id": "98b83859",
   "metadata": {},
   "outputs": [],
   "source": [
    "train_dataset = Image_Dataset('./train_photos', train_data, train_transform)\n",
    "val_dataset = Image_Dataset('./train_photos', val_data, val_transform)\n",
    "test_dataset = Image_Dataset('./train_photos', test_data, val_transform)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "id": "3317a41e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# this part can be tuned\n",
    "class Resnext50(nn.Module):\n",
    "    def __init__(self):\n",
    "        super().__init__()\n",
    "        resnet = models.resnext50_32x4d(pretrained=True)\n",
    "        resnet.fc = nn.Sequential(\n",
    "            nn.Dropout(p=0.2),\n",
    "            nn.Linear(in_features=resnet.fc.in_features, out_features=9)\n",
    "        )\n",
    "        self.model = resnet\n",
    "        self.activation = nn.Sigmoid()\n",
    "\n",
    "    def forward(self, x):\n",
    "        return self.activation(self.model(x))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "id": "fe349bfd",
   "metadata": {},
   "outputs": [],
   "source": [
    "# this part can be tuned\n",
    "\n",
    "device = torch.device('cuda')\n",
    "model = Resnext50()\n",
    "optimizer = optim.SGD(model.parameters(), lr=0.1)\n",
    "loss_func = nn.BCELoss()\n",
    "\n",
    "epoch = 5\n",
    "#batch_size= 16\n",
    "# lr = 1e-4 \n",
    "\n",
    " \n",
    "#train_batch_size = 48\n",
    "#val_batch_size =64\n",
    "train_dataloader = DataLoader(train_dataset, batch_size=16,  shuffle=True,drop_last=True)\n",
    "val_dataloader = DataLoader(val_dataset, batch_size=64)\n",
    "test_dataloader = DataLoader(test_dataset, batch_size=64)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "id": "344b0a8c",
   "metadata": {},
   "outputs": [],
   "source": [
    "def train(model, optimizer,  device):\n",
    "    train_precision = []\n",
    "    train_recall=[]\n",
    "    train_loss = []\n",
    "    \n",
    "    val_precision = []\n",
    "    val_recall=[]\n",
    "    val_loss = []\n",
    "    \n",
    "    best_f1 = 0\n",
    "    best_model = None\n",
    "    best_i = 0\n",
    "    \n",
    "    \n",
    "    model = model.to(device)\n",
    "    \n",
    "    for i in range(epoch):\n",
    "        model.train()\n",
    "        \n",
    "        batch_precision=[]\n",
    "        batch_recall=[]\n",
    "        batch_loss =[]\n",
    "        for images, labels in tqdm(train_dataloader):\n",
    "            images, labels = images.to(device), labels.to(device)\n",
    "            output = model(images)\n",
    "            loss = loss_func(output, labels.type(torch.float))\n",
    "            optimizer.zero_grad()\n",
    "            loss.backward()\n",
    "            optimizer.step()\n",
    "\n",
    "            with torch.no_grad():\n",
    "                pred = (output>0.5).cpu()\n",
    "                labels = labels.cpu()\n",
    "                batch_precision.append(precision_score(labels, pred,average='micro'))\n",
    "                batch_recall.append(recall_score(labels, pred,average='micro'))\n",
    "                batch_loss.append(loss.cpu())\n",
    "                \n",
    "        precision = np.array(batch_precision).mean()\n",
    "        recall = np.array(batch_recall).mean()\n",
    "        loss = np.array(batch_loss).mean()\n",
    "        \n",
    "        train_precision.append(precision)\n",
    "        train_recall.append(recall)\n",
    "        train_loss.append(loss)\n",
    "        print(\"train_precision:{:.4f}, train_recall:{:.4f}, train_loss:{:.4f}\".format(precision,recall,loss))\n",
    "\n",
    "        # validation\n",
    "        model.eval()\n",
    "        model_result = []\n",
    "        targets = []\n",
    "        with torch.no_grad():\n",
    "            for images, labels in tqdm(val_dataloader):\n",
    "                images = images.to(device)\n",
    "                model_batch_result = model(images)\n",
    "                model_result.extend(model_batch_result.cpu().numpy())\n",
    "                targets.extend(labels.cpu().numpy())\n",
    "        \n",
    "        loss = loss_func(torch.FloatTensor(model_result), torch.FloatTensor(targets))\n",
    "        pred = np.array(np.array(model_result) >0.5, dtype=float)\n",
    "        val_precision.append(precision_score(targets,pred,average='micro'))\n",
    "        val_recall.append(recall_score(targets,pred,average='micro'))\n",
    "        val_loss.append(loss.item())\n",
    "        f1 = f1_score(targets,pred,average='micro')\n",
    "        \n",
    "        if  f1> best_f1:\n",
    "            best_f1 = f1\n",
    "            best_model = deepcopy(model.state_dict())\n",
    "            best_i = i\n",
    "\n",
    "        if i % 20 == 0:\n",
    "            print('Epoch {}, val_precision:{:.4f}, val_recall:{:.4f}, val_loss:{:.4f}, f1:{:.4f}'.format(i, val_precision[-1],val_recall[-1],val_loss[-1],f1))\n",
    "\n",
    "    print('best epoch {}, train precision {:.4f} val precision {:.4f}, f1 {:.4f}'.format(best_i, train_precision[best_i], val_precision[best_i], best_f1))\n",
    "    model.load_state_dict(best_model)\n",
    "    return train_precision, train_recall, train_loss, val_precision, val_recall, val_loss"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "d33c5eb7",
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_graph(train_precision, train_recall, train_loss, val_precision, val_recall, val_loss):\n",
    "    x=range(1,epoch+1)\n",
    "    plt.xlabel(\"iteration\")\n",
    "    plt.plot(x,train_precision,label=\"train_precision\")\n",
    "    plt.plot(x,train_recall,label=\"train_recall\")\n",
    "    plt.plot(x,val_precision,label=\"val_precision\")\n",
    "    plt.plot(x,val_recall,label=\"val_recall\")\n",
    "    plt.legend(loc=\"upper left\")\n",
    "    plt.ylim([0,1])\n",
    "    xint = range(1, epoch+1)\n",
    "    matplotlib.pyplot.xticks(xint)\n",
    "    plt.show()\n",
    "\n",
    "    plt.xlabel(\"iteration\")\n",
    "    plt.plot(x,train_loss,label=\"train_loss\")\n",
    "    plt.plot(x,val_loss,label=\"val_loss\")\n",
    "    plt.legend(loc=\"lower left\")\n",
    "    xint = range(1, epoch+1)\n",
    "    matplotlib.pyplot.xticks(xint)\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "15386066",
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 5936/5936 [1:00:55<00:00,  1.62it/s]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "train_precision:0.7642, train_recall:0.7594, train_loss:0.4965\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 165/165 [02:55<00:00,  1.06s/it]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 0, val_precision:0.7578, val_recall:0.8245, val_loss:0.4674, f1:0.7897\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      " 88%|████████▊ | 5222/5936 [53:52<07:22,  1.62it/s] \n"
     ]
    },
    {
     "ename": "RuntimeError",
     "evalue": "[enforce fail at ..\\c10\\core\\impl\\alloc_cpu.cpp:72] data. DefaultCPUAllocator: not enough memory: you tried to allocate 12582912 bytes.",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mRuntimeError\u001b[0m                              Traceback (most recent call last)",
      "Cell \u001b[1;32mIn [54], line 4\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[39m# Training\u001b[39;00m\n\u001b[0;32m      3\u001b[0m torch\u001b[39m.\u001b[39mcuda\u001b[39m.\u001b[39mempty_cache()\n\u001b[1;32m----> 4\u001b[0m train_precision, train_recall, train_loss, val_precision, val_recall, val_loss \u001b[39m=\u001b[39m train(model, optimizer, device)\n",
      "Cell \u001b[1;32mIn [52], line 23\u001b[0m, in \u001b[0;36mtrain\u001b[1;34m(model, optimizer, device)\u001b[0m\n\u001b[0;32m     21\u001b[0m batch_recall\u001b[39m=\u001b[39m[]\n\u001b[0;32m     22\u001b[0m batch_loss \u001b[39m=\u001b[39m[]\n\u001b[1;32m---> 23\u001b[0m \u001b[39mfor\u001b[39;00m images, labels \u001b[39min\u001b[39;00m tqdm(train_dataloader):\n\u001b[0;32m     24\u001b[0m     images, labels \u001b[39m=\u001b[39m images\u001b[39m.\u001b[39mto(device), labels\u001b[39m.\u001b[39mto(device)\n\u001b[0;32m     25\u001b[0m     output \u001b[39m=\u001b[39m model(images)\n",
      "File \u001b[1;32mc:\\Users\\CHAN Hei Yuk\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\tqdm\\std.py:1195\u001b[0m, in \u001b[0;36mtqdm.__iter__\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m   1192\u001b[0m time \u001b[39m=\u001b[39m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_time\n\u001b[0;32m   1194\u001b[0m \u001b[39mtry\u001b[39;00m:\n\u001b[1;32m-> 1195\u001b[0m     \u001b[39mfor\u001b[39;00m obj \u001b[39min\u001b[39;00m iterable:\n\u001b[0;32m   1196\u001b[0m         \u001b[39myield\u001b[39;00m obj\n\u001b[0;32m   1197\u001b[0m         \u001b[39m# Update and possibly print the progressbar.\u001b[39;00m\n\u001b[0;32m   1198\u001b[0m         \u001b[39m# Note: does not call self.update(1) for speed optimisation.\u001b[39;00m\n",
      "File \u001b[1;32mc:\\Users\\CHAN Hei Yuk\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\torch\\utils\\data\\dataloader.py:628\u001b[0m, in \u001b[0;36m_BaseDataLoaderIter.__next__\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    625\u001b[0m \u001b[39mif\u001b[39;00m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_sampler_iter \u001b[39mis\u001b[39;00m \u001b[39mNone\u001b[39;00m:\n\u001b[0;32m    626\u001b[0m     \u001b[39m# TODO(https://github.com/pytorch/pytorch/issues/76750)\u001b[39;00m\n\u001b[0;32m    627\u001b[0m     \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_reset()  \u001b[39m# type: ignore[call-arg]\u001b[39;00m\n\u001b[1;32m--> 628\u001b[0m data \u001b[39m=\u001b[39m \u001b[39mself\u001b[39;49m\u001b[39m.\u001b[39;49m_next_data()\n\u001b[0;32m    629\u001b[0m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_num_yielded \u001b[39m+\u001b[39m\u001b[39m=\u001b[39m \u001b[39m1\u001b[39m\n\u001b[0;32m    630\u001b[0m \u001b[39mif\u001b[39;00m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_dataset_kind \u001b[39m==\u001b[39m _DatasetKind\u001b[39m.\u001b[39mIterable \u001b[39mand\u001b[39;00m \\\n\u001b[0;32m    631\u001b[0m         \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_IterableDataset_len_called \u001b[39mis\u001b[39;00m \u001b[39mnot\u001b[39;00m \u001b[39mNone\u001b[39;00m \u001b[39mand\u001b[39;00m \\\n\u001b[0;32m    632\u001b[0m         \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_num_yielded \u001b[39m>\u001b[39m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_IterableDataset_len_called:\n",
      "File \u001b[1;32mc:\\Users\\CHAN Hei Yuk\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\torch\\utils\\data\\dataloader.py:671\u001b[0m, in \u001b[0;36m_SingleProcessDataLoaderIter._next_data\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    669\u001b[0m \u001b[39mdef\u001b[39;00m \u001b[39m_next_data\u001b[39m(\u001b[39mself\u001b[39m):\n\u001b[0;32m    670\u001b[0m     index \u001b[39m=\u001b[39m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_next_index()  \u001b[39m# may raise StopIteration\u001b[39;00m\n\u001b[1;32m--> 671\u001b[0m     data \u001b[39m=\u001b[39m \u001b[39mself\u001b[39;49m\u001b[39m.\u001b[39;49m_dataset_fetcher\u001b[39m.\u001b[39;49mfetch(index)  \u001b[39m# may raise StopIteration\u001b[39;00m\n\u001b[0;32m    672\u001b[0m     \u001b[39mif\u001b[39;00m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_pin_memory:\n\u001b[0;32m    673\u001b[0m         data \u001b[39m=\u001b[39m _utils\u001b[39m.\u001b[39mpin_memory\u001b[39m.\u001b[39mpin_memory(data, \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_pin_memory_device)\n",
      "File \u001b[1;32mc:\\Users\\CHAN Hei Yuk\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\torch\\utils\\data\\_utils\\fetch.py:61\u001b[0m, in \u001b[0;36m_MapDatasetFetcher.fetch\u001b[1;34m(self, possibly_batched_index)\u001b[0m\n\u001b[0;32m     59\u001b[0m \u001b[39melse\u001b[39;00m:\n\u001b[0;32m     60\u001b[0m     data \u001b[39m=\u001b[39m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39mdataset[possibly_batched_index]\n\u001b[1;32m---> 61\u001b[0m \u001b[39mreturn\u001b[39;00m \u001b[39mself\u001b[39;49m\u001b[39m.\u001b[39;49mcollate_fn(data)\n",
      "File \u001b[1;32mc:\\Users\\CHAN Hei Yuk\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\torch\\utils\\data\\_utils\\collate.py:265\u001b[0m, in \u001b[0;36mdefault_collate\u001b[1;34m(batch)\u001b[0m\n\u001b[0;32m    204\u001b[0m \u001b[39mdef\u001b[39;00m \u001b[39mdefault_collate\u001b[39m(batch):\n\u001b[0;32m    205\u001b[0m     \u001b[39mr\u001b[39m\u001b[39m\"\"\"\u001b[39;00m\n\u001b[0;32m    206\u001b[0m \u001b[39m        Function that takes in a batch of data and puts the elements within the batch\u001b[39;00m\n\u001b[0;32m    207\u001b[0m \u001b[39m        into a tensor with an additional outer dimension - batch size. The exact output type can be\u001b[39;00m\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m    263\u001b[0m \u001b[39m            >>> default_collate(batch)  # Handle `CustomType` automatically\u001b[39;00m\n\u001b[0;32m    264\u001b[0m \u001b[39m    \"\"\"\u001b[39;00m\n\u001b[1;32m--> 265\u001b[0m     \u001b[39mreturn\u001b[39;00m collate(batch, collate_fn_map\u001b[39m=\u001b[39;49mdefault_collate_fn_map)\n",
      "File \u001b[1;32mc:\\Users\\CHAN Hei Yuk\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\torch\\utils\\data\\_utils\\collate.py:143\u001b[0m, in \u001b[0;36mcollate\u001b[1;34m(batch, collate_fn_map)\u001b[0m\n\u001b[0;32m    140\u001b[0m transposed \u001b[39m=\u001b[39m \u001b[39mlist\u001b[39m(\u001b[39mzip\u001b[39m(\u001b[39m*\u001b[39mbatch))  \u001b[39m# It may be accessed twice, so we use a list.\u001b[39;00m\n\u001b[0;32m    142\u001b[0m \u001b[39mif\u001b[39;00m \u001b[39misinstance\u001b[39m(elem, \u001b[39mtuple\u001b[39m):\n\u001b[1;32m--> 143\u001b[0m     \u001b[39mreturn\u001b[39;00m [collate(samples, collate_fn_map\u001b[39m=\u001b[39mcollate_fn_map) \u001b[39mfor\u001b[39;00m samples \u001b[39min\u001b[39;00m transposed]  \u001b[39m# Backwards compatibility.\u001b[39;00m\n\u001b[0;32m    144\u001b[0m \u001b[39melse\u001b[39;00m:\n\u001b[0;32m    145\u001b[0m     \u001b[39mtry\u001b[39;00m:\n",
      "File \u001b[1;32mc:\\Users\\CHAN Hei Yuk\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\torch\\utils\\data\\_utils\\collate.py:143\u001b[0m, in \u001b[0;36m<listcomp>\u001b[1;34m(.0)\u001b[0m\n\u001b[0;32m    140\u001b[0m transposed \u001b[39m=\u001b[39m \u001b[39mlist\u001b[39m(\u001b[39mzip\u001b[39m(\u001b[39m*\u001b[39mbatch))  \u001b[39m# It may be accessed twice, so we use a list.\u001b[39;00m\n\u001b[0;32m    142\u001b[0m \u001b[39mif\u001b[39;00m \u001b[39misinstance\u001b[39m(elem, \u001b[39mtuple\u001b[39m):\n\u001b[1;32m--> 143\u001b[0m     \u001b[39mreturn\u001b[39;00m [collate(samples, collate_fn_map\u001b[39m=\u001b[39;49mcollate_fn_map) \u001b[39mfor\u001b[39;00m samples \u001b[39min\u001b[39;00m transposed]  \u001b[39m# Backwards compatibility.\u001b[39;00m\n\u001b[0;32m    144\u001b[0m \u001b[39melse\u001b[39;00m:\n\u001b[0;32m    145\u001b[0m     \u001b[39mtry\u001b[39;00m:\n",
      "File \u001b[1;32mc:\\Users\\CHAN Hei Yuk\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\torch\\utils\\data\\_utils\\collate.py:120\u001b[0m, in \u001b[0;36mcollate\u001b[1;34m(batch, collate_fn_map)\u001b[0m\n\u001b[0;32m    118\u001b[0m \u001b[39mif\u001b[39;00m collate_fn_map \u001b[39mis\u001b[39;00m \u001b[39mnot\u001b[39;00m \u001b[39mNone\u001b[39;00m:\n\u001b[0;32m    119\u001b[0m     \u001b[39mif\u001b[39;00m elem_type \u001b[39min\u001b[39;00m collate_fn_map:\n\u001b[1;32m--> 120\u001b[0m         \u001b[39mreturn\u001b[39;00m collate_fn_map[elem_type](batch, collate_fn_map\u001b[39m=\u001b[39;49mcollate_fn_map)\n\u001b[0;32m    122\u001b[0m     \u001b[39mfor\u001b[39;00m collate_type \u001b[39min\u001b[39;00m collate_fn_map:\n\u001b[0;32m    123\u001b[0m         \u001b[39mif\u001b[39;00m \u001b[39misinstance\u001b[39m(elem, collate_type):\n",
      "File \u001b[1;32mc:\\Users\\CHAN Hei Yuk\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\torch\\utils\\data\\_utils\\collate.py:163\u001b[0m, in \u001b[0;36mcollate_tensor_fn\u001b[1;34m(batch, collate_fn_map)\u001b[0m\n\u001b[0;32m    161\u001b[0m     storage \u001b[39m=\u001b[39m elem\u001b[39m.\u001b[39mstorage()\u001b[39m.\u001b[39m_new_shared(numel, device\u001b[39m=\u001b[39melem\u001b[39m.\u001b[39mdevice)\n\u001b[0;32m    162\u001b[0m     out \u001b[39m=\u001b[39m elem\u001b[39m.\u001b[39mnew(storage)\u001b[39m.\u001b[39mresize_(\u001b[39mlen\u001b[39m(batch), \u001b[39m*\u001b[39m\u001b[39mlist\u001b[39m(elem\u001b[39m.\u001b[39msize()))\n\u001b[1;32m--> 163\u001b[0m \u001b[39mreturn\u001b[39;00m torch\u001b[39m.\u001b[39;49mstack(batch, \u001b[39m0\u001b[39;49m, out\u001b[39m=\u001b[39;49mout)\n",
      "\u001b[1;31mRuntimeError\u001b[0m: [enforce fail at ..\\c10\\core\\impl\\alloc_cpu.cpp:72] data. DefaultCPUAllocator: not enough memory: you tried to allocate 12582912 bytes."
     ]
    }
   ],
   "source": [
    "# Training\n",
    "\n",
    "torch.cuda.empty_cache()\n",
    "train_precision, train_recall, train_loss, val_precision, val_recall, val_loss = train(model, optimizer, device)\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b9d48b6d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Save model\n",
    "PATH=\"./models/best_model.pt\"\n",
    "os.makedirs(\"models\", exist_ok=True)\n",
    "torch.save(model.state_dict(), PATH)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "42dec323",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Resnext50(\n",
       "  (model): ResNet(\n",
       "    (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)\n",
       "    (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "    (relu): ReLU(inplace=True)\n",
       "    (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)\n",
       "    (layer1): Sequential(\n",
       "      (0): Bottleneck(\n",
       "        (conv1): Conv2d(64, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(128, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "        (downsample): Sequential(\n",
       "          (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "          (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        )\n",
       "      )\n",
       "      (1): Bottleneck(\n",
       "        (conv1): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(128, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "      )\n",
       "      (2): Bottleneck(\n",
       "        (conv1): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(128, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "      )\n",
       "    )\n",
       "    (layer2): Sequential(\n",
       "      (0): Bottleneck(\n",
       "        (conv1): Conv2d(256, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "        (downsample): Sequential(\n",
       "          (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)\n",
       "          (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        )\n",
       "      )\n",
       "      (1): Bottleneck(\n",
       "        (conv1): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "      )\n",
       "      (2): Bottleneck(\n",
       "        (conv1): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "      )\n",
       "      (3): Bottleneck(\n",
       "        (conv1): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "      )\n",
       "    )\n",
       "    (layer3): Sequential(\n",
       "      (0): Bottleneck(\n",
       "        (conv1): Conv2d(512, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "        (downsample): Sequential(\n",
       "          (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(2, 2), bias=False)\n",
       "          (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        )\n",
       "      )\n",
       "      (1): Bottleneck(\n",
       "        (conv1): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "      )\n",
       "      (2): Bottleneck(\n",
       "        (conv1): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "      )\n",
       "      (3): Bottleneck(\n",
       "        (conv1): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "      )\n",
       "      (4): Bottleneck(\n",
       "        (conv1): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "      )\n",
       "      (5): Bottleneck(\n",
       "        (conv1): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "      )\n",
       "    )\n",
       "    (layer4): Sequential(\n",
       "      (0): Bottleneck(\n",
       "        (conv1): Conv2d(1024, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "        (downsample): Sequential(\n",
       "          (0): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(2, 2), bias=False)\n",
       "          (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        )\n",
       "      )\n",
       "      (1): Bottleneck(\n",
       "        (conv1): Conv2d(2048, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "      )\n",
       "      (2): Bottleneck(\n",
       "        (conv1): Conv2d(2048, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv2): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)\n",
       "        (bn2): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (conv3): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
       "        (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
       "        (relu): ReLU(inplace=True)\n",
       "      )\n",
       "    )\n",
       "    (avgpool): AdaptiveAvgPool2d(output_size=(1, 1))\n",
       "    (fc): Sequential(\n",
       "      (0): Dropout(p=0.2, inplace=False)\n",
       "      (1): Linear(in_features=2048, out_features=9, bias=True)\n",
       "    )\n",
       "  )\n",
       "  (activation): Sigmoid()\n",
       ")"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# load best_model\n",
    "model=Resnext50()\n",
    "model.load_state_dict(torch.load(PATH))\n",
    "model.to(device)\n",
    "model.eval()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8d7ea730",
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "data": {
      "image/png": "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r7zyChdddBE9e/Zk7ty5/OUvf6l3wOvzzz/PwIEDufzyyxk6dCiWZfHGG29oYjQRkWbAsJpBp3lJSQnp6ekUFxeTlpaW8F5lZSXbt2+nS5cu+Hw+m2rYcixbtowLL7yQgwcPNnlsRkui3y8RkaY70vm7JrWMiIiIiK0URk4xN998MykpKXUuN998s93VExGRU5AGsJ5iZs2aVe+so2lpabRu3VqXu4qIyAmlMHKKad26Na1bt7a7GiIiInHqphERERFbKYyIiIiIrRRGRERExFYKIyIiImIrhRERERGxlcJIC9C5c2fmzJljdzWOmmEYvPrqqwDs2LEDwzBYtWqVrXUSEZHjT5f22uSCCy6gX79+xyREfPLJJyQnJx99pURERGygMHKSsiyLaDRa503kDteqVauToh4iIiJNoW4aG4wfP553332Xxx57DMMwMAyDefPmYRgGb775JgMHDsTr9bJ8+XK2bt3KlVdeSW5uLikpKQwePJi33347YX+Hd9MYhsFzzz3HVVddRVJSEnl5eSxatKhBdVu2bFmd9TBNk9mzZ9OlSxf8fj99+/bl5ZdfTth23bp1XH755aSlpZGamsp5553H1q1bgVjrzcUXX0xOTg7p6ekMGzaMzz777Oi+SBERaRFaXhixLAgF7FkaOI36Y489xtChQ/n5z3/O7t272b17Nx06dADgnnvu4cEHH2T9+vXk5+dTVlbGpZdeytKlS/n8888ZOXIkBQUF7Ny584jHmDlzJj/5yU9YvXo1l156KWPGjKGoqKjBX+Ph9Zg9ezb/8z//w9y5c1m3bh133HEH//7v/867774LwDfffMP555+P1+vlX//6FytXruSnP/0pkUgEgNLSUsaNG8fy5cv58MMPycvL49JLL6W0tLTBdRIRkZap5bW9h8vhgXb2HPvX34Ln+8dupKen4/F4SEpKok2bNgBs2LABiN075uKLL46vm5WVRd++feOv77//fhYuXMiiRYuYOHFivccYP348o0ePBuCBBx7g8ccf5+OPP2bkyJEN+ig16xEMBnnggQd4++23GTp0KACnn346y5cv549//CPDhg3jySefJD09nQULFuB2uwHo1q1bfH8XXXRRwv6feeYZMjIyePfdd7n88ssbVCcREWmZWl4YaeYGDRqU8LqsrIwZM2bw+uuvs3v3biKRCBUVFd/bMpKfnx9/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IiIiIrZSGBERERFbKYyIiIiIrRRGRERExFYKIyIiImIrhRERERGxlcKIiIiI2EphRERERGylMCIiIiK2UhgRERERWymMiIiIiK0URkRERMRWCiMiIiJiK4URERERsZXCiIiIiNhKYURERERspTAiIiIitlIYEREREVspjIiIiIitFEZERETEVgojIiIiYiuFEREREbGVwoiIiIjYSmFEREREbKUwIiIiIrZSGBERERFbKYyIiIiIrRRGRERExFYKIyIiImKrJoWRJ598ks6dO+Pz+RgyZAgff/zxEdf/7rvvmDBhAm3btsXr9dKtWzfeeOONJlVYREREWhZXYzd46aWXmDRpEnPnzmXIkCHMmTOHESNGsHHjRlq3bl1r/VAoxMUXX0zr1q15+eWXad++PV999RUZGRnHov4iIiLSzBmWZVmN2WDIkCEMHjyYJ554AgDTNOnQoQO33HIL99xzT631586dy+9//3s2bNiA2+1uUiVLSkpIT0+nuLiYtLS0Ju1DRERETqyGnr8b1U0TCoVYuXIlw4cPP7QDh4Phw4ezYsWKOrdZtGgRQ4cOZcKECeTm5tK7d28eeOABotFovccJBoOUlJQkLCIiItIyNSqM7N+/n2g0Sm5ubkJ5bm4uhYWFdW6zbds2Xn75ZaLRKG+88QZTp07lkUce4Te/+U29x5k9ezbp6enxpUOHDo2ppoiIiDQjx/1qGtM0ad26Nc888wwDBw7k2muv5d5772Xu3Ln1bjNlyhSKi4vjy65du453NUVERMQmjRrAmpOTg9PpZM+ePQnle/bsoU2bNnVu07ZtW9xuN06nM17Ws2dPCgsLCYVCeDyeWtt4vV68Xm9jqiYiIiLNVKNaRjweDwMHDmTp0qXxMtM0Wbp0KUOHDq1zm3POOYctW7Zgmma8bNOmTbRt27bOICIiIiKnlkZ300yaNIlnn32WF154gfXr1/Mf//EfBAIBbrzxRgDGjh3LlClT4uv/x3/8B0VFRdx2221s2rSJ119/nQceeIAJEyYcu08hIiIizVaj5xm59tpr2bdvH9OmTaOwsJB+/fqxePHi+KDWnTt34nAcyjgdOnTgrbfe4o477iA/P5/27dtz2223cffddx+7TyEiIiLNVqPnGbGD5hkRERFpfo7LPCMiIiIix5rCiIiIiNhKYURERERspTAiIiIitlIYEREREVspjIiIiIitFEZERETEVgojIiIiYiuFEREREbGVwoiIiIjYSmFEREREbKUwIiIiIrZSGBERERFbKYyIiIiIrRRGRERExFYKIyIiImIrhRERERGxlcKIiIiI2EphRERERGylMCIiIiK2UhgRERERWymMiIiIiK0URkRERMRWCiMiIiJiK4URERERsZXCiIiIiNhKYURERERspTAiIiIitlIYEREREVspjIiIiIitFEZERETEVgojIiIiYiuFEREREbGVwoiIiIjYSmFEREREbKUwIiIiIrZSGBERERFbKYyIiIiIrRRGRERExFYKIyIiImIrhRERERGxlcKIiIiI2EphRERERGylMCIiIiK2UhgRERERWymMiIiIiK0URkRERMRWCiMiIiJiK4URERERsZXCiIiIiNhKYURERERspTAiIiIitlIYEREREVspjIiIiIitFEZERETEVgojIiIiYiuFEREREbGVwoiIiIjYSmFEREREbKUwIiIiIrZSGBERERFbKYyIiIiIrRRGRERExFZNCiNPPvkknTt3xufzMWTIED7++OMGbbdgwQIMw2DUqFFNOayIiIi0QI0OIy+99BKTJk1i+vTpfPbZZ/Tt25cRI0awd+/eI263Y8cOJk+ezHnnndfkyoqIiEjL0+gw8uijj/Lzn/+cG2+8kV69ejF37lySkpL47//+73q3iUajjBkzhpkzZ3L66acfVYVFRESkZWlUGAmFQqxcuZLhw4cf2oHDwfDhw1mxYkW9282aNYvWrVvzs5/9rEHHCQaDlJSUJCwiIiLSMjUqjOzfv59oNEpubm5CeW5uLoWFhXVus3z5cv70pz/x7LPPNvg4s2fPJj09Pb506NChMdUUERGRZuS4Xk1TWlrKDTfcwLPPPktOTk6Dt5syZQrFxcXxZdeuXcexliIiImInV2NWzsnJwel0smfPnoTyPXv20KZNm1rrb926lR07dlBQUBAvM00zdmCXi40bN3LGGWfU2s7r9eL1ehtTNREREWmmGtUy4vF4GDhwIEuXLo2XmabJ0qVLGTp0aK31e/TowZo1a1i1alV8ueKKK7jwwgtZtWqVul9ERESkcS0jAJMmTWLcuHEMGjSIs846izlz5hAIBLjxxhsBGDt2LO3bt2f27Nn4fD569+6dsH1GRgZArXIRERE5NTU6jFx77bXs27ePadOmUVhYSL9+/Vi8eHF8UOvOnTtxODSxq4iIiDSMYVmWZXclvk9JSQnp6ekUFxeTlpZmd3VERESkARp6/lYThoiIiNhKYURERERspTAiIiIitlIYEREREVspjIiIiIitFEZERETEVgojIiIiYiuFEREREbGVwoiIiIjYSmFEREREbKUwIiIiIrZSGBERERFbKYyIiIiIrRRGRERExFYKIyIiImIrhRERERGxlcKIiIiI2EphRERERGylMCIiIiK2UhgRERERWymMiIiIiK0URkRERMRWCiMiIiJiK4URERERsZXCiIiIiNhKYURERERspTAiIiIitlIYEREREVspjIiIiIitFEZERETEVgojIiIiYiuFEREREbGVwoiIiIjYSmFEREREbKUwIiIiIrZSGBERERFbKYyIiIiIrRRGRERExFYKIyIiImIrhRERERGxlcKIiIiI2EphRERERGylMCIiIiK2UhgRERERWymMiIiIiK0URkRERMRWCiMiIiJiK4URERERsZXCiIiIiNhKYURERERspTAiIiIitlIYEREREVspjIiIiIitFEZERETEVgojIiIiYiuFEREREbGVwoiIiIjYSmFEREREbKUwIiIiIrZSGBERERFbKYyIiIiIrRRGRERExFYKIyIiImKrJoWRJ598ks6dO+Pz+RgyZAgff/xxves+++yznHfeeWRmZpKZmcnw4cOPuL6IiIicWhodRl566SUmTZrE9OnT+eyzz+jbty8jRoxg7969da6/bNkyRo8ezTvvvMOKFSvo0KED//Zv/8Y333xz1JUXERGR5s+wLMtqzAZDhgxh8ODBPPHEEwCYpkmHDh245ZZbuOeee753+2g0SmZmJk888QRjx45t0DFLSkpIT0+nuLiYtLS0xlRXREREbNLQ83ejWkZCoRArV65k+PDhh3bgcDB8+HBWrFjRoH2Ul5cTDofJysqqd51gMEhJSUnCIiIiIi1To8LI/v37iUaj5ObmJpTn5uZSWFjYoH3cfffdtGvXLiHQHG727Nmkp6fHlw4dOjSmmiIiItKMnNCraR588EEWLFjAwoUL8fl89a43ZcoUiouL48uuXbtOYC1FRETkRHI1ZuWcnBycTid79uxJKN+zZw9t2rQ54rYPP/wwDz74IG+//Tb5+flHXNfr9eL1ehtTNREREWmmGtUy4vF4GDhwIEuXLo2XmabJ0qVLGTp0aL3b/e53v+P+++9n8eLFDBo0qOm1FRERkRanUS0jAJMmTWLcuHEMGjSIs846izlz5hAIBLjxxhsBGDt2LO3bt2f27NkAPPTQQ0ybNo358+fTuXPn+NiSlJQUUlJSjuFHERERkeao0WHk2muvZd++fUybNo3CwkL69evH4sWL44Nad+7cicNxqMHl6aefJhQKcfXVVyfsZ/r06cyYMePoai8iIiLNXqPnGbGD5hkRERFpfo7LPCMiIiIix5rCiIiIiNhKYURERERspTAiIiIitlIYEREREVspjIiIiIitFEZERETEVgojIiIiYiuFEREREbGVwoiIiIjYSmFEREREbKUwIiIiIrZSGBERERFbKYyIiIiIrRRGRERExFYKIyIiImIrhRERERGxlcKIiIiI2EphRERERGylMCIiIiK2UhgRERERWymMiIiIiK0URkRERMRWCiMiIiJiK4URERERsZXCiIiIiNhKYURERERspTAiIiIitlIYEREREVspjIiIiIitFEZERETEVgojIiIiYiuFEREREbGVwoiIiIjYSmFEREREbKUwIiIiIrZSGBERERFbKYyIiIiIrRRGRERExFYKIyIiImIrhRERERGxlcKIiIiI2EphRERERGylMCIiIiK2UhgRERERWymMiIiIiK0URkRERMRWCiMiIiJiK4URERERsZXCiIiIiNhKYURERERspTAiIiIitlIYEREREVspjIiIiIitFEZERETEVgojIiIiYiuFEREREbGVwoiIiIjYSmFEREREbKUwIiIiIrZSGBERERFbKYyIiIiIrRRGRERExFZNCiNPPvkknTt3xufzMWTIED7++OMjrv+3v/2NHj164PP56NOnD2+88UaTKisiIiItT6PDyEsvvcSkSZOYPn06n332GX379mXEiBHs3bu3zvU/+OADRo8ezc9+9jM+//xzRo0axahRo1i7du1RV15ERESaP8OyLKsxGwwZMoTBgwfzxBNPAGCaJh06dOCWW27hnnvuqbX+tddeSyAQ4LXXXouX/eAHP6Bfv37MnTu3QccsKSkhPT2d4uJi0tLSGlNdERERsUlDz9+uxuw0FAqxcuVKpkyZEi9zOBwMHz6cFStW1LnNihUrmDRpUkLZiBEjePXVV+s9TjAYJBgMxl8XFxcDsQ8lIiIizUP1efv72j0aFUb2799PNBol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0kssX76ciRMnJmz/8MMP07dvXz7//HOmTp0KxO72Om/ePL788ksee+wxnn32Wf7rv/4LgGuvvZY777yTM888M368a6+9tla9AoEAI0aMIDMzk08++YS//e1vvP3227WO/84777B161beeecdXnjhBebNm6ebYYqchNRNIyL1ysrKwul0kpqamtBNMnv2bMaMGRMfR5KXl8fjjz/OsGHDePrpp/H5fABcdNFF3HnnnQn7vO++++LPO3fuzOTJk1mwYAG/+tWv8Pv9pKSk4HK5jtgtM3/+fCorK/mf//kfkpOTAXjiiScoKCjgoYceIjc3F4DMzEyeeOIJnE4nPXr04LLLLmPp0qX8/Oc/Pybfj4gcGwojItJoX3zxBatXr+bFF1+Ml1mWhWmabN++nZ49ewIwaNCgWtu+9NJLPP7442zdupWysjIikQhpaWmNOv769evp27dvPIgAnHPOOZimycaNG+Nh5Mwzz8TpdMbXadu2LWvWrGnUsUTk+FMYEZFGKysr45e//CW33nprrfc6duwYf14zLACsWLGCMWPGMHPmTEaMGEF6ejoLFizgkUceOS71dLvdCa8Nw8A0zeNyLBFpOoURETkij8dDNBpNKBswYABffvklXbt2bdS+PvjgAzp16sS9994bL/vqq6++93iH69mzJ/PmzSMQCMQDz/vvv4/D4aB79+6NqpOI2E8DWEXkiDp37sx7773HN998w/79+4HYFTEffPABEydOZNWqVWzevJl//OMftQaQHi4vL4+dO3eyYMECtm7dyuOPP87ChQtrHW/79u2sWrWK/fv3EwwGa+1nzJgx+Hw+xo0bx9q1a3nnnXe45ZZbuOGGG+JdNCLSfCiMiMgRzZo1ix07dnDGGWfQqlUrAPLz83n33XfZtGkT5513Hv3792fatGm0a9fuiPu64ooruOOOO5g4cSL9+vXjgw8+iF9lU+3HP/4xI0eO5MILL6RVq1b85S9/qbWfpKQk3nrrLYqKihg8eDBXX301P/zhD3niiSeO3QcXkRNGM7CKiIiIrdQyIiIiIrZSGBERERFbKYyIiIiIrRRGRERExFYKIyIiImIrhRERERGxlcKIiIiI2EphRERERGylMCIiIiK2UhgRERERWymMiIiIiK0URkRERMRW/x8D923LzUy3MwAAAABJRU5ErkJggg==",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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AwbYPDw8bPXr17d9//33hapt2bJlNsB25syZvH3ffvutrXHjxjZXV1dbaGio7e233853zowZM2z169e3ubm52QIDA22333573mPffPONrWnTpjZ3d3ebv7+/rUePHrb09PQrvn5Bn6mIiKNISs20vfT9dluDf/9iC33uJ1vocz/ZHvx0g2338VSjS3M4//T9/XdFHmEpD87lWGg8frEhr71zYi88Xa/+1/7ee++xZ88emjZtysSJEwHYsWMHAM8//zxvv/02devWpXLlyhw+fJibb76Z1157DTc3Nz777DP69u1LbGwstWrVuuJrTJgwgbfeeovJkyczbdo0Bg8ezKFDh/D3L1rjr+joaO68805efvllBg0axNq1a3n88cepUqUK9913Hxs3buSJJ57g888/p0OHDpw+fZpVq1YB9lWI7777bt566y0GDhxIWloaq1at0vVfESmzqnq78XK/JjzYuQ7v/b6X7zYdYcnORH7flciAFjV4KiqMWlW0NlhRVcjAUhb4+vri6uqKp6dn3p1Uu3fvBuwL8d100015x/r7+xMREZH351deeYUFCxbwww8/MHLkyCu+xn333cfdd98NwOuvv87777/PX3/9Re/evYtU65QpU+jRowcvvvgiAGFhYezcuZPJkydz3333ER8fj5eXF7feeive3t6EhobSsmVLwB5YcnNzue222wgNDQWgWbNmRXp9ERFHVLOyJ5P/FcEjXesyZckeftmWwILNR/lxyzHuahvCqBsbEOSjqQ+FVSEDi4eLEzsn9jLsta9X69at8/05PT2dl19+mZ9//jkvAJw7d474+Ph/fJ7mzZvn/beXlxc+Pj4kJSUVuZ5du3bRv3//fPs6duzI1KlTsVgs3HTTTYSGhlK3bl169+5N7969GThwIJ6enkRERNCjRw+aNWtGr1696NmzJ3fccQeVK+t6r4iUD/UDvflgcCTbjqQw+bdYVu45wRd/xvNt9BGGdajNo13qUdnL1egyHV6JLhznqEwmE56uzoZsxbFK69/v9hk7diwLFizg9ddfZ9WqVcTExNCsWTOys7P/8XlcXFwu+3u5sE5OcfL29mbTpk18/fXXVKtWjfHjxxMREUFycjJOTk4sWbKEX3/9lcaNGzNt2jTCw8M5ePBgsdchImKkZjV9+ez+tsx9+AYiQyuTmWPlwxUH6PLWMqYt3UtGVq7RJTq0ChlYygpXV1cslqsv+7xmzRruu+8+Bg4cSLNmzQgODiYuLq7kCzyvUaNGrFmz5rKaLm1O6OzsTFRUFG+99RZbt24lLi6OP/74A7AHpY4dOzJhwgQ2b96Mq6srCxYsKLX6RURK0w11q/Dto+35+L7WNKrmQ1pWLu8s2UOXt5bx8eqDZOZouf+CVMhLQmVF7dq1Wb9+PXFxcVSqVOmKox8NGjRg/vz59O3bF5PJxIsvvlgiIyVX8vTTT9OmTRteeeUVBg0axLp165g+fToffPABAD/99BMHDhygS5cuVK5cmV9++QWr1Up4eDjr169n6dKl9OzZk8DAQNavX8+JEydo1KhRqdUvIlLaTCYTNzYMoltYID9tO86U32KJO3WWiT/t5L+rDvBkVANub1UTZyeNK1ygvwkHNnbsWJycnGjcuDFVq1a94pyUKVOmULlyZTp06EDfvn3p1asXrVq1KrU6W7Vqxf/+9z/mzp1L06ZNGT9+PBMnTuS+++4D7IsFzp8/nxtvvJFGjRoxa9Ysvv76a5o0aYKPjw8rV67k5ptvJiwsjBdeeIF33nmHPn36lFr9IiJGMZtN9IuozpIxXZl0WzOCfdw5lpLJc99to+e7K/lp6zGsVt01CWCylYP7R1NTU/H19SUlJQUfH598j2VmZnLw4EHq1KmjhejKCX2mIlJeZeZY+OLPQ8xYto8zZ3MAaFLdh7G9wukWVrXcdav/p+/vv9MIi4iIiINwd3Hiwc51Wflsd0ZHNaCSmzM7jqUy/JMNDPrwTzbEnTa6RMMosMhlHn30USpVqlTg9uijjxpdnohIueft7sLoqDBWPtudhzrXwdXZzF9xp/nXrHXc98lfbD+aYnSJpU6XhOQySUlJpKamFviYj48PgYGBpVxRfvpMRaSiOZ5yjml/7GPehsNYzs9puaV5NZ6+KYy6VSsZXN21K8olId0lJJcJDAw0PJSIiMhF1Xw9eH1gMx7uXJd3f9/DD1uO8fPW4yzansAdrWryZFQDqvt5GF1midIlIRERkTKidoAX793Vkl+e6ExUo0AsVhvzNh6m2+TlTPxxJyfTs4wuscQosIiIiJQxjar58N9hbfjusfa0q+NPtsXKx2sO0vWtZUz5LZbUzByjSyx2CiwiIiJlVGSoP3MfvoHPH2hL85q+ZGRbeP+PfXR5axkfrtjPuezys2quAouIiEgZZjKZ6NygKt+P6Mise1tRP7ASyWdzmPTrbrpOXsYXfx4ix1J6q5+XFAUWERGRcsBkMtG7aTUWj+7C2/+KoIafB0lpWbywcDs93lnBws1H8+4wKosUWMqx2rVrM3Xq1EIdazKZWLhwYYnWIyIiJc/JbOKOyJr8MbYrE/o1IaCSG/GnzzJ6Xgw3v7eKJTsTKYsrmiiwiIiIlENuzk4M61Cblc9245le4fi4OxObmMZDn23ktplrWbv/pNElFokCi4iISDnm6erMiO71WfXsjTzerR4eLk5sjk/mntnrufe/64k5nGx0iYVSMQOLzQbZGcZshRyG+7//+z+qV6+O1Zp/olT//v25//772b9/P/379ycoKIhKlSrRpk0bfv/992L7K9q2bRs33ngjHh4eVKlShYcffpj09PS8x5cvX07btm3x8vLCz8+Pjh07cujQIQC2bNlC9+7d8fb2xsfHh8jISDZu3FhstYmISNH5errwbO+GrHi2G8Pah+LiZGL1vpMMmLGGRz7fyJ7ENKNL/EcVc6XbnLPwenVjXvvfx8DV66qH/etf/2LUqFEsW7aMHj16AHD69GkWLVrEL7/8Qnp6OjfffDOvvfYabm5ufPbZZ/Tt25fY2Fhq1ap1XSVmZGTQq1cv2rdvz4YNG0hKSuLBBx9k5MiRzJkzh9zcXAYMGMBDDz3E119/TXZ2Nn/99VdeF9HBgwfTsmVLZs6ciZOTEzExMbi4uFxXTSIiUjwCvd2Z0L8pD3auy9Tf97Jg8xEW70jkt52JDGxZg6eiwgjx9zS6zMtUzMBSBlSuXJk+ffrw1Vdf5QWWb7/9loCAALp3747ZbCYiIiLv+FdeeYUFCxbwww8/MHLkyOt67a+++orMzEw+++wzvLzs4Wr69On07duXN998ExcXF1JSUrj11lupV68eAI0aNco7Pz4+nmeeeYaGDRsC0KBBg+uqR0REil+Ivyfv3BnBo13rMmXJHn7dnsD8TUf5ccsx7m5bi5Hd6xPo4zj92ipmYHHxtI90GPXahTR48GAeeughPvjgA9zc3Pjyyy+56667MJvNpKen8/LLL/Pzzz9z/PhxcnNzOXfuHPHx8ddd4q5du4iIiMgLKwAdO3bEarUSGxtLly5duO++++jVqxc33XQTUVFR3HnnnVSrVg2AMWPG8OCDD/L5558TFRXFv/71r7xgIyIijqVBkDcz741k65FkJi+OZdXek3y27hD/23iY4R3r8EiXuvh5uhpdZgWdw2Iy2S/LGLGdv2xSGH379sVms/Hzzz9z+PBhVq1axeDBgwEYO3YsCxYs4PXXX2fVqlXExMTQrFkzsrOzS+pvLZ9PPvmEdevW0aFDB+bNm0dYWBh//vknAC+//DI7duzglltu4Y8//qBx48YsWLCgVOoSEZFr07ymH58/0I6vH7qBVrX8yMyxMnP5fjq/tYzpf+wlIyvX0PoqZmApI9zd3bntttv48ssv+frrrwkPD6dVq1YArFmzhvvuu4+BAwfSrFkzgoODiYuLK5bXbdSoEVu2bCEjIyNv35o1azCbzYSHh+fta9myJePGjWPt2rU0bdqUr776Ku+xsLAwnnrqKX777Tduu+02Pvnkk2KpTURESlb7elX47rEO/HdoaxoGe5OWmcvbv+2h6+RlxJ86a1hdCiwObvDgwfz88898/PHHeaMrYJ8XMn/+fGJiYtiyZQv33HPPZXcUXc9ruru7M2zYMLZv386yZcsYNWoUQ4YMISgoiIMHDzJu3DjWrVvHoUOH+O2339i7dy+NGjXi3LlzjBw5kuXLl3Po0CHWrFnDhg0b8s1xERERx2YymYhqHMQvT3TmvbtaEFrFk2q+HoT4exhWU8Wcw1KG3Hjjjfj7+xMbG8s999yTt3/KlCncf//9dOjQgYCAAJ577jlSU1OL5TU9PT1ZvHgxTz75JG3atMHT05Pbb7+dKVOm5D2+e/duPv30U06dOkW1atUYMWIEjzzyCLm5uZw6dYqhQ4eSmJhIQEAAt912GxMmTCiW2kREpPSYzSb6t6jBzc2qcSItK+9uUCOYbGVxfd6/SU1NxdfXl5SUFHx8fPI9lpmZycGDB6lTpw7u7o4z21munT5TEZHy4Z++v/9Ol4RERETE4SmwVABffvkllSpVKnBr0qSJ0eWJiIhcleawVAD9+vWjXbt2BT6mFWhFRKQsUGCpALy9vfH29ja6DBERkWtWYS4JlYO5xXKePksRkYqn3AeWC5c8zp41brEbKV4XPktdzhIRqTjK/SUhJycn/Pz8SEpKAuxriBh5H7lcO5vNxtmzZ0lKSsLPzw8nJyejSxIRkVJS7gMLQHBwMEBeaJGyzc/PL+8zFRGRiqFCBBaTyUS1atUIDAwkJyfH6HLkOri4uGhkRUSkAqoQgeUCJycnfdmJiIiUQeV+0q2IiIiUfQosIiIi4vAUWERERMThlYs5LBcWEktNTTW4EhERESmsC9/bhVkQtFwElrS0NABCQkIMrkRERESKKi0tDV9f3388xmQrB+ucW61Wjh07hre3d7EvCpeamkpISAiHDx/Gx8enWJ9bSoc+w7JNn1/Zp8+w7Cupz9Bms5GWlkb16tUxm/95lkq5GGExm83UrFmzRF/Dx8dH/9DKOH2GZZs+v7JPn2HZVxKf4dVGVi7QpFsRERFxeAosIiIi4vAUWK7Czc2Nl156CTc3N6NLkWukz7Bs0+dX9ukzLPsc4TMsF5NuRUREpHzTCIuIiIg4PAUWERERcXgKLCIiIuLwFFhERETE4SmwXMHKlSvp27cv1atXx2QysXDhQqNLkiKYNGkSbdq0wdvbm8DAQAYMGEBsbKzRZUkRzJw5k+bNm+ctVNW+fXt+/fVXo8uS6/DGG29gMpkYPXq00aVIIb388suYTKZ8W8OGDQ2pRYHlCjIyMoiIiGDGjBlGlyLXYMWKFYwYMYI///yTJUuWkJOTQ8+ePcnIyDC6NCmkmjVr8sYbbxAdHc3GjRu58cYb6d+/Pzt27DC6NLkGGzZs4MMPP6R58+ZGlyJF1KRJE44fP563rV692pA6ysXS/CWhT58+9OnTx+gy5BotWrQo35/nzJlDYGAg0dHRdOnSxaCqpCj69u2b78+vvfYaM2fO5M8//6RJkyYGVSXXIj09ncGDBzN79mxeffVVo8uRInJ2diY4ONjoMjTCIhVDSkoKAP7+/gZXItfCYrEwd+5cMjIyaN++vdHlSBGNGDGCW265haioKKNLkWuwd+9eqlevTt26dRk8eDDx8fGG1KERFin3rFYro0ePpmPHjjRt2tTocqQItm3bRvv27cnMzKRSpUosWLCAxo0bG12WFMHcuXPZtGkTGzZsMLoUuQbt2rVjzpw5hIeHc/z4cSZMmEDnzp3Zvn073t7epVqLAouUeyNGjGD79u2GXXeVaxceHk5MTAwpKSl8++23DBs2jBUrVii0lBGHDx/mySefZMmSJbi7uxtdjlyDS6dGNG/enHbt2hEaGsr//vc/HnjggVKtRYFFyrWRI0fy008/sXLlSmrWrGl0OVJErq6u1K9fH4DIyEg2bNjAe++9x4cffmhwZVIY0dHRJCUl0apVq7x9FouFlStXMn36dLKysnBycjKwQikqPz8/wsLC2LdvX6m/tgKLlEs2m41Ro0axYMECli9fTp06dYwuSYqB1WolKyvL6DKkkHr06MG2bdvy7Rs+fDgNGzbkueeeU1gpg9LT09m/fz9Dhgwp9ddWYLmC9PT0fAny4MGDxMTE4O/vT61atQysTApjxIgRfPXVV3z//fd4e3uTkJAAgK+vLx4eHgZXJ4Uxbtw4+vTpQ61atUhLS+Orr75i+fLlLF682OjSpJC8vb0vmzfm5eVFlSpVNJ+sjBg7dix9+/YlNDSUY8eO8dJLL+Hk5MTdd99d6rUosFzBxo0b6d69e96fx4wZA8CwYcOYM2eOQVVJYc2cOROAbt265dv/ySefcN9995V+QVJkSUlJDB06lOPHj+Pr60vz5s1ZvHgxN910k9GliVQYR44c4e677+bUqVNUrVqVTp068eeff1K1atVSr8Vks9lspf6qIiIiIkWgdVhERETE4SmwiIiIiMNTYBERERGHp8AiIiIiDk+BRURERByeAouIiIg4PAUWERERcXgKLCIiIuLwFFhEpMi6devG6NGjjS4jH5PJxMKFC40uQ0RKiFa6FZEiO336NC4uLnh7e1O7dm1Gjx5dagHm5ZdfZuHChcTExOTbn5CQQOXKlXFzcyuVOkSkdKmXkIgUmb+/f7E/Z3Z2Nq6urtd8fnBwcDFWIyKORpeERKTILlwS6tatG4cOHeKpp57CZDJhMpnyjlm9ejWdO3fGw8ODkJAQnnjiCTIyMvIer127Nq+88gpDhw7Fx8eHhx9+GIDnnnuOsLAwPD09qVu3Li+++CI5OTkAzJkzhwkTJrBly5a817vQjPTvl4S2bdvGjTfeiIeHB1WqVOHhhx8mPT097/H77ruPAQMG8Pbbb1OtWjWqVKnCiBEj8l5LRByLAouIXLP58+dTs2ZNJk6cyPHjxzl+/DgA+/fvp3fv3tx+++1s3bqVefPmsXr1akaOHJnv/LfffpuIiAg2b97Miy++CIC3tzdz5sxh586dvPfee8yePZt3330XgEGDBvH000/TpEmTvNcbNGjQZXVlZGTQq1cvKleuzIYNG/jmm2/4/fffL3v9ZcuWsX//fpYtW8ann37KnDlz1I1dxEHpkpCIXDN/f3+cnJzw9vbOd0lm0qRJDB48OG9eS4MGDXj//ffp2rUrM2fOxN3dHYAbb7yRp59+Ot9zvvDCC3n/Xbt2bcaOHcvcuXN59tln8fDwoFKlSjg7O//jJaCvvvqKzMxMPvvsM7y8vACYPn06ffv25c033yQoKAiAypUrM336dJycnGjYsCG33HILS5cu5aGHHiqWvx8RKT4KLCJS7LZs2cLWrVv58ssv8/bZbDasVisHDx6kUaNGALRu3fqyc+fNm8f777/P/v37SU9PJzc3Fx8fnyK9/q5du4iIiMgLKwAdO3bEarUSGxubF1iaNGmCk5NT3jHVqlVj27ZtRXotESkdCiwiUuzS09N55JFHeOKJJy57rFatWnn/fWmgAFi3bh2DBw9mwoQJ9OrVC19fX+bOncs777xTInW6uLjk+7PJZMJqtZbIa4nI9VFgEZHr4urqisViybevVatW7Ny5k/r16xfpudauXUtoaCj/+c9/8vYdOnToqq/3d40aNWLOnDlkZGTkhaI1a9ZgNpsJDw8vUk0i4hg06VZErkvt2rVZuXIlR48e5eTJk4D9Tp+1a9cycuRIYmJi2Lt3L99///1lk17/rkGDBsTHxzN37lz279/P+++/z4IFCy57vYMHDxITE8PJkyfJysq67HkGDx6Mu7s7w4YNY/v27SxbtoxRo0YxZMiQvMtBIlK2KLCIyHWZOHEicXFx1KtXj6pVqwLQvHlzVqxYwZ49e+jcuTMtW7Zk/PjxVK9e/R+fq1+/fjz11FOMHDmSFi1asHbt2ry7hy64/fbb6d27N927d6dq1ap8/fXXlz2Pp6cnixcv5vTp07Rp04Y77riDHj16MH369OJ74yJSqrTSrYiIiDg8jbCIiIiIw1NgEREREYenwCIiIiIOT4FFREREHJ4Ci4iIiDg8BRYRERFxeAosIiIi4vAUWERERMThKbCIiIiIw1NgEREREYenwCIiIiIO7/8Bk/CYhJC5m9sAAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plot_graph(train_precision, train_recall, train_loss, val_precision, val_recall, val_loss)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1fc762df",
   "metadata": {},
   "outputs": [],
   "source": [
    "# TODO:\n",
    "# add regularization, tune hyper parameters"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3.10.7 64-bit",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.7"
  },
  "vscode": {
   "interpreter": {
    "hash": "79dbd3016ff75198adb468dc3a0b7f453decbd4641557b58fb3c9af07df02fc9"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
